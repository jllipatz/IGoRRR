{"version": "Hoc opus, hic labor est",
 "init":{
   "error.envir": "Le paramètre 'envir' doit être un 'environment'",
   "require.msg": "*** Les packages suivants n'ont pas été chargés en mémoire :",
   "require.ask": "Puis-je charger en mémoire les packages manquants?",
   "require.err": "*** ABANDON: Le code généré par IGoR ne pourrait pas fonctionner!",
   "example1": "enquête",
   "example2": "nanopop",
   "example.sf": "Martinique"
 },
 "any":{
   "error": "*** ERREUR ***",
   "create": "Créer la table",
   "replace": "Remplacer",
   "table": "<table>",
   "all": "<toutes>",
   "none": "<aucune>",
   "var": "Variable",
   "vars": "Variables",
   "var.qual": "Variable qualitative",
   "var.quan": "Variable quantitative",
   "var.qual.x": "Variable qualitative en abscisse",
   "var.quan.x": "Variable quantitative en abscisse",
   "var.quan.y": "Variable quantitative en ordonnée",
   "x": "Abscisses",
   "y": "Ordonnées",
   "row":  "Observation...",
   "rows": "Observations",
   "col": "<colonne>",
   "cols": "<colonnes>",
   "col.chr": "<colonne de type 'character'>",
   "cols.chr": "<colonnes de type 'character'>",
   "cols.fct": "<colonnes de type 'factor'>",
   "col.discrete": "<colonne (hors type 'double')>",
   "cols.discrete": "<colonnes (hors type 'double')>",
   "col.numeric": "<colonne de type numerique>",
   "col.enum": "<colonne de type 'character' ou énumération>",
   "old.var": "Variable à convertir",
   "new.col": "Colonne à créer ou remplacer",
   "where": "Restreindre aux observations vérifiant la condition",
   "group": "Grouper par modalité des variables",
   "weight": "Pondérer avec",
   "drop": "Inverser la sélection",
   "stringsAsFactors": "Convertir les chaînes de caractères en facteurs",
   "na.rm": "Ignorer les valeurs manquantes",
   "browse": "Parcourir...",
   "graphics.browse": "Enregistrer l'image sous...",
   "path": "Chemin d'accès au fichier",
   "out": "Mémoriser le résultat sous le nom",
   "fun": "Fonction",
   "funs": "<fonctions>",
   "fun.name":{
     "none.fun":     "<fonction>",
	 "none.op":      "<operateur>",
	 "head.any":     "Fonctions générales",
	 "head.class":   "Fonctions spécifiques",
	 "identity":     "Copier à l'identique",
	 "lag":			 "Valeur précédente",
	 "lead":         "Valeur suivante",
	 "ifelse":       "Remplacer une modalité",
	 "coalesce":     "Remplacer les valeurs manquantes...",
	 "na.locf":      "Propager les valeurs non manquantes",
     "make.names":   "Standardiser",
	 "str_to_lower": "Mettre en minuscules",
	 "str_to_upper": "Mettre en majuscules",
	 ".renumber":    "Numéroter",
	 ".prefix":      "Préfixer",
	 ".suffix":      "Suffixer",
	 "iconv":        "Changer d'encodage...",
	 "str_sub2":     "Extraire la chaîne entre les positions...",
	 "str_sub1":     "Extraire la chaîne à partir de la position...",
	 "str_detect":   "Chercher une expression régulière...",
	 "str_extract":  "Extraire une expression régulière...",
	 "str_replace":  "Remplacer une expression régulière...",
	 "str_split":    "Eclater selon une expression régulière...",
	 ".collapse":    "Concaténer la colonne",
	 "startsWith":   "commence par",
	 "endsWith":     "finit par",
	 "matches":      "contient l'expression régulière",
	 "str_length":   "Calculer la longueur",
	 "day":          "Numéro de jour du mois",
	 "month":        "Numéro de mois",
	 "year":         "Année",
	 "wday":         "Numéro de jour dans la semaine",
	 "pastedTo":     "concaténé à",
	 "not":          "Inverser",
	 "isTRUE":       "est vrai",
	 "isEQ":         "est égal à",
	 "isNE":         "est différent de",
	 "and":          "et",
	 "or":           "ou",
	 "isNA":         "est à valeur manquante",
	 "belongsTo":    "appartient à",
	 "isGT":         "est supérieur à",
	 "isGE":         "est supérieur ou égal à",
	 "isEQ.stat":    "est égal à la statistique...",
	 "isGT.stat":    "est supérieur à la statistique...",
	 "plus":         "plus",
	 "minus":        "moins",
	 "times":        "fois",
	 "dividedBy":    "divisé par",
	 ".negate":      "Changer le signe",
	 "n":            "Nombre d'observations",
	 "v":            "Comptage",
	 "sum":          "Somme",
	 "mean":         "Moyenne",
	 "median":       "Médiane",
	 "quantile":     "Quantile...",
	 "q1":           "Premier quartile",
	 "q3":           "Dernier quartile",
	 "p10":          "Premier décile",
	 "p90":          "Dernier décile",
	 "sd":           "Ecart type",
	 "var":          "Variance",
	 "min":          "Minimum",
	 "max":          "Maximum",
	 "first":        "Première valeur",
	 "last":         "Dernière valeur",
	 "all":			 "Pourcentage",
	 "row":			 "Pourcentage ligne",
	 "col":			 "Pourcentage colonne",
	 "sprintf":      "Formatter...",
	 "as.character": "Transformer en caractères"
   },
   "operator": "Opérateur",
   "from": "depuis",
   "to": "jusqu'à",
   "by":  "par",
   "into": "vers",
   "prx": "expression",
   "layout": "Mise en page",
   "title": "Titre",
   "titleh": "Titre :",
   "color": "Couleur",
   "error": "*** ERREUR ***",
   "copy.require" : "UTILISE ",
   "copy.invalid" : "ATTENTION : Code syntaxiquement incorrect"
 },
 "dashboard":{
   "manage":     "Gérer les tables",
   "update":     "Gérer les variables",
   "extract":    "Extraire",
   "reshape":    "Restructurer",
   "merge":      "Enrichir",
   "statistics": "Statistiques",
   "graphics":   "Graphiques",
   "msg.version": "ATTENTION: La version de R que vous utilisez est antérieure à la 3.4, ce sera à vos risques et périls!",
   "quit":       "Quitter",
   "quit.cancel": "Annuler",
   "quit.ok":     "Confirmer",
   "msg.drop": "ATTENTION : Le contenu de la mémoire ne sera pas sauvegardé!",
   "msg.save": "L'intégralite des tables en mémoire va être sauvegardé."
 },
 "all":{
   "main.data": "Table courante",
   "freemem": "Mémoire libre",
   "copy": "Copier le code",
   "select.1": "sélectionnées...",
   "select.2": "du type...",
   "select.type.numeric":   "numérique",
   "select.type.double":    "numérique virgule flottante",
   "select.type.integer":   "numérique entier",
   "select.type.logical":   "booléen",
   "select.type.factor":    "énumération (facteur)",
   "select.type.character": "caractère",
   "select.type.Date":      "date",
   "select.3": "toutes",
   "select.4": "dont le nom débute par...",
   "select.5": "dont le nom finit par...",
   "select.6": "dont le nom contient...",
   "select.7": "dont le nom contient l'expression régulière...",
   "select.0": "entre les positions...",
   "select.range.start": "Première colonne",
   "select.range.end":   "Dernière colonne",
   "expr.0": "Expression non assistée",
   "expr.1": "Numéro d'observation",
   "expr.2": "Mode assisté sur une variable",
   "expr.3": "Mode assisté entre deux variables",
   "join.data": "Seconde table en entrée",
   "join.keys": "Clés de jointure",
   "titles": "Titres",
   "subtitle": "Sous-titre",
   "source": "Source",
   "height": "Hauteur du graphique (x100 pixels)",
   "graphics.options": "Options du graphique",
   "graphics.save": "Sauvegarder le graphique",
   "graphics.save.as": "Sauvegarder le graphique sous",
   "msg.warning": " # *** Maître(sse)! Etes vous sûr de vouloir employer %s?",
   "msg.result": "NOTE : La table '%s' comporte %d ligne(s) et %d colonne(s)."
 },
 "contents":{
   "menu.title": "Visualiser la structure",
   "page.title": "Variables de la table courante",
   "info":[
     "En R, une <strong>'table de données'</strong> est une structure rectangulaire constituée de :<br>",
     "- <strong>'lignes'</strong>: une pour chaque entité observée,<br>",
     "- <strong>'colonnes'</strong>: une pour chaque variable mesurée sur les observations.<br>",
     "Chaque colonne est caractérisée par son <em>'nom'</em>, son type de données (<em>'classe'</em>),",
     "et peut porter des informations complémentaires dont le <em>'label'</em>.",
     "La classe d'une variable conditionne les usages qui pourront être faits de ses données.",
	 "Il peut y avoir pluseurs classes pour une variable.<br>",
     "Le <em>'label'</em> est un héritage de SAS et est utilisé pour enrichir les graphiques,",
	 "il peut être positionné dans la page <em>créer une variable</em> du sous-menu <em>Gérer les variables</em>."],
   "columns": {
     "position": "Position",
     "name":  "Nom",
     "class": "Classe",
     "label": "Label"},
   "sort": "Trier par"
 },
 "view":{
   "menu.title": "Visualiser les données",
   "page.title": "Données de la table courante",
   "info":[
     "Les colonnes ont des noms, les lignes aussi (<em>'rownames'</em>), par défaut le numéro d'observation.",
     "Les modifications apportées à une table conservent rarement les noms des lignes, mais ceux ci sont également rarement utilisés.<br>",
     "La fonction <code>'group_by'</code> du package <strong>'dplyr'</strong> permet de considérer une table comme comme un empilement de sous-tables,",
     "une pour chaque modalité du croisement des variables citées, et ceci sans qu'aucun réordonnancement de la table ne soit nécessaire.",
     "L'application d'une autre fonction de <strong>'dplyr'</strong> se comportera alors comme une application de la fonction à chacune des sous-tables,",
     "puis en la concaténation des différents résultats. Cette fonctionnalité est reprise ici à titre purement démonstratif."],
   "page.size": "Lignes par page",
   "page.no": "Page",
   "ncols": "colonnes (%d)",
   "nrows": "rownames (%d)",
   "group.no": "Groupe"
 },
 "browse":{
   "menu.title": "Visualiser une observation",
   "page.title": "Visualisation d’une observation",
   "info":[
     "Cette page permet de <span style='color: blue'>visualiser une table observation par observation</span>", 
     "de la même façon que le <em>'fsbrowse'</em> de SAS (mais en mieux!).",
     "Elle reprend les facilités de sélection de variables et d'observations présentes dans les pages d'extraction de tables.",
     "L'affichage peut être partagé entre variables de type caractère sélectionnées sur leur nom (par exemple pour identifier les observations) ",
     "et variables sélectionnées sur leurs caractéristiques."],
   "vars": "Afficher les variables...",
   "ids": "Variables d'identification",
   "ncols": "Nombre de colonnes",
   "label": "Utiliser les libellés de variable",
   "sort": "Trier les variables par leur nom",
   "row.type.no":   "de numéro",
   "row.type.name": "de nom...",
   "row.type.id":   "d'identifiant...",
   "msg.nobs": "Il y a %d observations correspondant à cet identifiant!"
 },
 "distinct":{
   "menu.title": "Modalités des variables",
   "page.title": "Modalités des variables et dénombrements",
   "info":[
     "En l'absence de demande de comptage, la fonction <code>distinct</code> du package <strong>dplyr</strong>",
	 "<span style='color:blue'>extrait les modalités distinctes</span> d'une variable ou d'un croisement de variables.",
     "Si aucune variable n'est sélectionnée, la fonction <span style='color:blue'>extrait les observations distinctes</span>.<br>",
	 "On peut également <span style='color:blue'>compter le nombre d'occurences pour chaque croisement de variables</span>,",
     "en s'appuyant sur deux fonctions du package <strong>dplyr</strong> :",
     "soit sur <code>count</code> qui ne permet pas de modifier le nom de la variable recevant les comptages, soit sur <code>summarise</code>.",
     "Si aucune variable n'est sélectionnée, ces dernières fonctions retournent le nombre d'observations de la table."],
   "type.list": "Modalités distinctes",
   "type.count": "Compter les observations",
   "sort": "Trier les modalités",
   "count.var": "Nom de la variable de dénombrement",
   "msg.values": "NOTE : Il y a %d modalité(s) :\n %s.",
   "msg.count":  "NOTE : Il y a %d modalité(s) croisée(s).",
   "msg.rows":  "NOTE : Il y a %d différente(s) observation(s).",
   "msg.result": "NOTE : Le résultat aura %d ligne(s)."
 },
 "create":{
   "menu.title": "Créer une table ex nihilo",
   "page.title": "Créer une table ex nihilo",
   "info":[
     "La fonction <code>read.table</code> est la fonction standard permettant de lire des fichiers texte avec séparateurs",
     "dont les champs sont séparés par un nombre quelconque d'espaces.", 
     "Elle est utilisée ici dans sa capacité à lire à l'intérieur d'une chaîne de caractères comme s'il s'agissait d'un fichier.<br>",
     "La fonction devine le type des colonnes à créer en fonction des données qui lui sont fournies.<br>",
     "Le résultat deviendra la table courante, sauf si une table de même nom éxistait déjà."],
   "names": "Nom des colonnes (séparés par des espaces)",
   "na.strings": "Marqueur pour les valeurs manquantes de type caractère",
   "data": "Lignes de données (séparées par des espaces)",
   "msg.result": "NOTE : La table '%s' va avoir %d ligne(s) et %d colonne(s)."
 },
 "import":{
   "menu.title": "Importer",
   "page.title": "Lecture d'une table depuis un fichier",
   "info":[
     "La fonction <code>import</code> du package <strong>rio</strong> fournit une interface unifiée pour le",
	 "<span style='color:blue'>transfert en mémoire de données présentes dans un fichier</span>.",
     "Elle reconnaît de nombreux types de fichiers : <em>Excel</em>, <em>Calc</em>, <em>SAS</em>,",
     "mais aussi des formats universels : <em>CSV</em>, <em>DBF</em>, <em>json</em>,", 
     "ou des formats spécifiques à R : <em>RData</em>, <em>RDS</em>, <em>fst</em>, <em>feather</em>.<br>",
     "Selon le type du fichier, des paramètres de contrôle complémentaires pourront être précisés.<br>",
     "Le résultat deviendra la table courante, sauf si une table de même nom éxistait déjà."],
   "choose": "Sélectionnez un fichier",
   "encoding": "Encodage",
   "header": "Importer le nom des colonnes",
   "vars": "Variables à conserver :",
   "expr": "Lignes à conserver :",
   "nrows": "Nombre maxi de lignes à lire :",
   "rdata.load": "Restaurer la table",
   "csv.chars": "Conserver en caractères",
   "csv.dec": "Virgule pour séparer les décimales",
   "xls.type.skip": "Sauter les premières lignes",
   "xls.type.insee": "En tête format insee.fr (5 lignes)",
   "xls.sheet": "Feuille",
   "ods.type.one": "Feuille",
   "ods.type.all": "Toutes les feuilles",
   "ods.all.skip": "...sauf la première",
   "ods.all.name": "Nom de la feuille dans",
   "ods.filter.skip": "Sauter les premières lignes",
   "ods.filter.range": "Plage de cellules (p.e. A5:G13)",
   "fst.filter": "Lire...",
   "fst.filter.all":   "toutes les lignes",
   "fst.filter.range": "une plage fixe",
   "fst.filter.where": "celles vérifiant une condition",
   "fst.from": "Première ligne à conserver :",
   "fst.to": "Dernière ligne à conserver :",
   "feather.where": "Restreindre aux lignes vérifiant une condition",
   "funcamp.key": "Clé"
 },
 "export":{
   "menu.title": "Exporter",
   "page.title": "Ecriture de tables dans un fichier",
   "info":[
     "La fonction <code>export</code> du package <strong>rio</strong> fournit une interface unifiée pour le",
	 "<span style='color:blue'>transfert dans un fichier de données présentes en mémoire</span>.",
     "Elle reconnaît de nombreux types de fichiers : <em>Excel</em>,",
     "mais aussi des formats universels : <em>CSV</em>, <em>DBF</em>, <em>json</em>,", 
     "ou des formats spécifiques à R : <em>fst</em>, <em>feather</em>.",
     "Elle permet de sauvegarder des tables dans les formats <em>RData</em> et <em>RDS</em>,", 
     "qui garantissent qu'une relecture ultérieure reconstituera les données dans leur état exact du moment de la sauvegarde.<br>",
     "Selon le type du fichier, des paramètres de contrôle complémentaires pourront être précisés.<br>",
     "Les formats <em>Excel (xlsx)</em>, et <em>RData</em> permettent de transférer plusieurs tables dans un même fichier."],
   "type.export": "Exporter la table courante (une table - un fichier)",
   "type.excel": "Exporter une liste de tables (Excel xlsx)",
   "type.rdata": "Sauvegarder une liste de tables (RData)",
   "path": "Chemin d'accès au fichier et type de fichier",
   "choose": "Exporter sous :",
   "export": "Exporter la table",
   "fst.compress": "Niveau de compression",
   "csv.function": "Fonction utilisée : <code>fwrite</code> du package <strong>data.table</strong>",
   "csv.sep": "Séparateur",
   "csv.sep.comma": "Virgule",
   "csv.sep.semicolon": "Point-virgule",
   "csv.quote": "Mettre des quotes autour des chaînes de caractères et facteurs",
   "excel.tables": "Tables à exporter",
   "excel.names": "Préciser le nom des feuilles",
   "excel": "Exporter les tables",
   "rdata.tables": "Tables à sauvegarder",
   "rdata.choose": "Sauvegarder sous :",
   "rdata": "Sauvegarder",
   "msg.result": "NOTE : La taille du fichier '%s' est de %d octets."
 },
 "tables":{
   "menu.title": "Lister les tables",
   "page.title": "Liste des tables",
   "info":[
     "Cette page recense toutes les tables, objets de type <strong>data.frame</strong> ou mieux, présents en mémoire ",
     "et associés à un symbole de l'<strong>environnement global</strong> qui leur sert de nom.<br>",
     "Les tables de test <em>enquête</em>, <em>Martinique</em> et <em>nanopop</em> sont (ré)initialisées au démarrage de la session IGoR.",
     "Les autres tables existeront jusqu'à ce que la session R soit fermée : si IGoR est lancé depuis RStudio ou RGui, jusqu'à la fermeture de RStudio ou RGui;",
     "si IGoR est lancé par un <em>.bat</em> jusqu'à la sortie d'IGoR.<br>"],
   "table": "Table",
   "source": "Source",
   "created": "Création",
   "delete": "Supprimer les références sélectionnées",
   "log": "Créer une table à partir du log",
   "log.out": "Mémoriser sous le nom :"
 },
 "rename":{
   "menu.title": "Renommer des variables",
   "page.title": "Renommer un ensemble de variables",
   "info":[
     "Les fonctions de la famille <code>rename</code> du package <strong>dplyr</strong> offrent une alternative à la fonction de base <code>names</code>",
     "en permettant, avec une syntaxe simple, de <span style='color:blue'>renommer des variables</span>",
     "présentes dans une table, en les sélectionnant soit toutes, soit par leur nom, soit par leur contenu.<br>",
     "Le nouveau nom peut soit être précisé explicitement, soit être déterminé par l'application d'une fonction.<br>",
     "En R, il n'est généralement pas possible de modifier un objet existant, aussi tout ce que fait la fonction c'est créer une nouvelle table",
     "contenant les données de l'ancienne table associées aux nouveaux noms.<br>",
     "<em>NOTE : si le nom de la table résultat est celui de la table courante, la page se réinitialise dès que la modification a fonctionné.</em>"],
   "rename": "Renommer les variables...",
   "expression": "expression",
   "suffix": "suffixe",
   "prefix": "préfixe",
   "to.expr": "par l'expression",
   "how.names": "Nouveaux noms",
   "how.fun": "Application d'une fonction",
   "names": "Nouveaux noms (séparés par des espaces)",
   "msg.badnames": "*** ERREUR: Il y a %d variable(s) à renommer!",
   "msg.duplicated": "ATTENTION: Les noms des nouvelles colonnes ne vont pas être uniques!",
   "msg.result": "NOTE : Il y a %d variable(s) à effectivement renommer."
 },
 "reclass":{
   "menu.title": "Changer le type des variables",
   "page.title": "Conversion de variables d'un type vers un autre",
   "info":[
     "Les fonctions de la famille <code>mutate</code> du package <strong>dplyr</strong> permettent aussi de",
     "<span style='color:blue'>changer le type d'une variable ou d'un ensemble de variables</span>.",
     "Les variables modifiées peuvent remplacer les anciennes, ou, si on ne réutilise pas leur nom, venir compléter la table résultat.<br>",
     "En R, il n'est généralement pas possible de modifier un objet existant, aussi tout ce que fait la fonction c'est créer une nouvelle table",
     "contenant les données de l'ancienne table modifiées sur les variables sélectionnées.<br>",
     "<em>NOTE : si le nom de la table résultat est celui de la table courante, la page se réinitialise dès que la modification a fonctionné.</em>"],
   "reclass": "Changer le type des variables...",
   "class": "vers le type",
   "class.none": "<type>",
   "class.factor": "énumération ('factor')",
   "class.as.character": "caractère",
   "class.as.double": "numérique double précision",
   "class.as.integer": "numérique entier",
   "class.as.logical": "booléen",
   "class.as.Date": "date",
   "short": "Réutiliser les noms",
   "empty": "Mettre 'valeur manquante' pour les chaînes vides",
   "format": "format",
   "formats": {
     "standard": "standard",
     "%d-%m-%Y": "JJ-MM-AAAA",
     "%d-%m-%y": "JJ-MM-AA"
   },
   "msg.factor": "ATTENTION : Convertir une variable facteur en autre chose que du caractère peut conduire à des résultats inattendus.",
   "msg.nop": "Il n'y a aucune variable à convertir!",
   "msg.result": "NOTE : Il y aura %d changement(s) de type."
 },
 "cut":{
   "menu.title": "Discrétiser une variable",
   "page.title": "Transformation d'une variable de quantitative à qualitative",
   "info":[
     "La fonction <code>cut</code>", 
     "<span style='color:blue'>transforme une variable quantitative en variable qualitative</span> sous forme de colonne de type 'facteur' ('énumération').",
     "L'ensemble des valeurs prise par la variable quantitative est découpé en tranches régulières ou non,",
     "le numéro de chaque tranche devenant une modalité de la nouvelle variable qualitative.<br>",
     "<em>NOTE : si le nom de la table résultat est celui de la table courante, la page se réinitialise dès que la modification a fonctionné.</em>"],
   "method": "Méthode",
   "methods":{
	  "value": "Valeurs individuelles",
      "breaks": "Tranches manuelles",
      "step": "Tranches régulières"
   },
   "breaks": "Breaks (séparés par des virgules)",
   "breaks.right": "Borne supérieure comprise",
   "step": "Taille des tranches",
   "min": "Valeur minimum",
   "max": "Valeur maximum"
 },
 "mutate":{
   "menu.title": "Créer une variable",
   "page.title": "Créer ou remplacer une variable",
   "info":[
     "La fonction <code>mutate</code> du package <strong>dplyr</strong> permet de",
     "<span style='color:blue'>créer une nouvelle variable</span> dans une table, ou si une variable de même nom existe déjà, de remplacer cette dernière.<br>",
     "Le calcul des données de la nouvelle variable peut être fait en groupant les observations sur les mêmes modalités d'un ensemble de variables.",
     "Dans ce cas le calcul sera réalisé groupe par groupe et la table résultat sera l'agrégation des résultats obtenus sur les différents groupes.",
     "Ceci n'est utile que lorsque le calcul utilise une fonction retournant un indicateur statistique : ce dernier sera produit groupe par groupe.<br>",
     "En R, il n'est généralement pas possible de modifier un objet existant, aussi tout ce que fait la fonction c'est créer une nouvelle table ",
     "contenant les données de l'ancienne table complétées par la nouvelle variable.<br>",
     "<em>NOTE : si le nom de la table résultat est celui de la table courante, la page se réinitialise dès que la modification a fonctionné.</em>"],
   "label": "Label :",
   "expr": "Formule de calcul",
   "operator": "<operateur>",
   "pipe": "Utiliser le pipe",
   "msg.duplicated": "ATTENTION : La colonne '%s' était déjà présente et sera remplacée!",
   "msg.result": "NOTE : La colonne '%s' va être de classe '%s'."
 },
 "mutate2":{
   "menu.title": "Modifier des variables",
   "page.title": "Modifier un ensemble de variables",
   "info":[
     "Les fonctions <code>mutate_all</code>, <code>mutate_at</code> et <code>mutate_if</code> du package <strong>dplyr</strong> permettent de", 
     "<span style='color:blue'>modifier des variables</span> présentes dans une table, en les sélectionnant soit toutes, soit par leur nom, soit par leur contenu.<br>",
     "En R, il n'est généralement pas possible de modifier un objet existant, aussi tout ce que font ces fonctions c'est créer une nouvelle table ",
     "contenant les données de l'ancienne table où ont été substituées les variables sélectionnées par des variables de même nom mais de contenu et/ou de type différent.<br>",
     "Il n'est pas possible d'assigner un nouveau nom au nouveau contenu et donc de conserver l'ancien contenu.<br>",
	 "Les transformations possibles dépendent du type des variables, ce qui interdit de mélanger les types.<br>",
     "<em>NOTE : si le nom de la table résultat est celui de la table courante, la page se réinitialise dès que la modification a fonctionné.</em>"],
   "mutate2": "Modifier les variables...",
   "msg.nop": "Aucune variable sélectionnée!",
   "msg.mixed": "ERREUR : La sélection contient des variables qui ont des types différents.",
   "msg.result": "NOTE : %d variable(s) de type '%s' à modifier."
},
 "slice":{
   "menu.title": "une plage d'observations",
   "page.title": "Sélectionner une plage d'observations",
   "info":[
     "Les fonctions <code>head</code> et <code>tail</code> construisent une nouvelle table limitée aux premières ou aux dernières observations.",
     "Elles sont complétées par la fonction <code>slice</code> du package <strong>dplyr</strong> qui permet d'extraire une plage d'observations en milieu de table,",
     "ou, au contraire de conserver uniquement les observations qui n'appartiennent pas à la plage spécifiée.",
	 "L'ensemble fournit une alternative plus parlante que la notation standard basée sur les crochets.<br>",
     "L'usage de ce type de sélection d'observations est généralement lié à un besoin d'extraire un jeu de test limité."],
   "top": "Numéro de la première observation",
   "end": "Numéro de la dernière observation"
  },
 "filter":{
   "menu.title": "des observations",
   "page.title": "Sélectionner des observations",
   "info":[
     "La fonction <code>filter</code> du package <strong>dplyr</strong> construit une",
     "<span style='color:blue'>nouvelle table limitée aux observations satisfaisant une certaine condition</span>.<br>",
     "Le test de la condition peut être fait en groupant les observations sur les mêmes modalités d'un ensemble de variables.",
     "Dans ce cas le test sera réalisé groupe par groupe et la table résultat sera l'agrégation des résultats obtenus sur les différents groupes.",
     "Ceci n'est utile que lorsque la condition utilise une fonction retournant un <em>indicateur statistique</em> : son calcul sera fait groupe par groupe et non sur l'ensemble de la table.<br>",
	 "Une table n'a pas vraiment de nom, ce sont les noms qui 'pointent' vers des objets : il n'est donc pas possible de renommer une table.",
	 "Par contre, ici, l'application d'une condition de sélection vide (<code>filter()</code>) permet de <span style='color:blue'>copier une table sous un autre nom</span>."],
   "filter": "Restreindre aux observations vérifiant la condition",
   "drop": "Inverser la condition",
   "where": "Formule restituant TRUE ou FALSE",
   "no": "Observation numéro",
   "stat": "Indicateur statistique sur la variable",
   "value": "Valeur",
   "values": "Valeurs v1,v2,v3,..."
 },
 "select":{
   "menu.title": "des variables",
   "page.title": "Sélectionner des variables",
   "info":[
     "La fonction <code>select</code> du package <strong>dplyr</strong> construit",
     "<span style='color:blue'>une nouvelle table limitée aux variables choisies</span>.<br>",
     "La sélection des variables peut se faire sur la forme du nom de la variable ou sur son type.<br>", 
     "La sélection de variables peut également permettre de réordonner les variables."],
   "select": "Conserver les variables...",
   "everything": "Compléter avec toutes les autres",
   "msg.result": "NOTE : Le résultat aura %d colonne(s) :\n  %s."
 },
 "summarise":{
   "menu.title": "Cumuler",
   "page.title": "Récapituler des variables quantitatives",
   "info":[
     "Les fonctions de la famille <code>summarise</code> du package <strong>dplyr</strong> prennent un ensemble d'observations et",
     "<span style='color:blue'>construisent une statistique synthétique ou un ensemble de statistiques synthétiques</span>,",
     "sur une variable ou une famille de variables. ",
     "Ces variables doivent êtres de type quantitatif, sauf pour deux cas offerts ici : ",
     "le dénombrement d'observations et le dénombrement d'observations dont les variables sélectionnées prennent une valeur précise.<br>",
     "Le résultat est une table comportant une seule ligne et autant de colonnes que de statistiques demandées, sauf si on traite la table courante par groupe d'observations,",
     "auquel cas le résultat aura autant de lignes que de groupes et comportera en outre les variables définissant les groupes."],
   "summarise": "Cumuler les variables...",
   "funs": "Calculer",
   "names": "Intitulés en clair",
   "value": "Valeur :",
   "msg.result": "NOTE : Il y a %d variable(s) à cumuler.",
   "msg.error1": "*** Maître(sse): R ne fait des moyennes que sur des colonnes numériques!"
},
 "gather":{
   "menu.title": "Transposer en format long",
   "page.title": "Passage du format large vers le format long",
   "info":[
     "La fonction <code>gather</code> du package <strong>tidyr</strong>", 
     "<span style='color:blue'>collecte de l'information stockée en ligne dans différentes colonnes en de l'information stockée en une unique colonne sur plusieurs lignes</span>.",
     "Les noms des colonnes d'origine est conservée dans une seconde colonne de la table résultat.<br>",
     "Il est possible de transposer un ensemble de variables de types différents, la colonne du résultat prendra un type compatible, généralement 'caractère'.<br>",
	 "Dans les versions récentes du package, la fonction  <code>pivot_longer</code> apporte des fonctionnalités supplémentaires."],
   "gather": "Transposer les variables...",
   "out.k": "Colonne recevant les noms (K)",
   "out.v": "Colonne recevant les valeurs (V)",
   "pivot": "Utiliser 'pivot_longer' au lieu de 'gather'",
   "msg.result": "NOTE : Le résultat aura %d colonne(s)."
 },
 "spread":{
   "menu.title": "Transposer en format large",
   "page.title": "Passage du format long vers le format large",
   "info":[
     "La fonction <code>spread</code> du package <strong>tidyr</strong>", 
     "<span style='color:blue'>ventile de l'information stockée sur plusieurs lignes dans une seule colonne en de l'information stockée sur une seule ligne dans différentes colonnes</span>.",
     "Une seconde colonne indique les noms des différentes colonnes à créer dans la table résultat.<br>",
	 "Dans les versions récentes du package, la fonction  <code>pivot_wider</code> apporte des fonctionnalités supplémentaires."],
   "var.k": "Noms des futures colonnes (K)",
   "var.v": "Valeurs des futures colonnes (V)",
   "pivot": "Utiliser 'pivot_wider' au lieu de 'spread'",
   "prefix": "Préfixer par '",
   "msg.error": "*** ERREUR : Les colonnes 'Noms' et 'Valeurs' sont identiques."
 },
 "arrange":{
   "menu.title": "Trier",
   "page.title": "Trier la table courante",
   "info":[
     "La fonction <code>arrange</code> du package <strong>dplyr</strong> construit une nouvelle",
     "<span style='color:blue'>table réordonnée selon l'ordre des modalités</span> prises par une ou plusieurs variables.<br>",
     "En R, le tri est un préalable inutile à la plupart des traitements : il n'est gère utile que pour la présentation de résultats..."],
   "desc": "Ordre décroissant pour les variables"
 },
 "union":{
   "menu.title": "Opérations ensemblistes",
   "page.title": "Opérations sur deux tables de même structure",
   "info":[
     "Le package <strong>dplyr</strong> offre une extension aux tables de données des fonctions ensemblistes du noyau R :",
	 "<code>union</code>, <code>intersect</code>,<code>setdiff</code>, respectivement union, intersection et différence.<br>",
	 "- Ces opérations considèrent les tables de données comme des ensembles au sens mathématique du terme.",
     "Il n'y a pas de doublon dans un ensemble : les doublons potentiels sont donc systématiquement retirés du résultat.<br>",
	 "- Ces opérations n'ont un sens qu'entre ensembles d'objets de même type : les tables impliquées doivent donc avoir la même structure.<br>",
     "<em>NOTE : la page se réinitialise dès que l'opération a fonctionné.</em>"],
   "type": "Collecter...",
   "types":{
     "union": "l'ensemble des lignes des deux tables",
     "intersect": "l'ensemble des lignes communes aux deux tables",
     "setdiff": "l'ensemble des lignes de la première table n'apparaissant pas dans la seconde"
   }
 },
"join":{
   "menu.title": "Jointure sur égalité",
   "page.title": "Jointure de deux tables sur égalité de clés",
   "info":[
     "Le package <strong>dplyr</strong> offre plusieurs fonctions d'<span style='color:blue'>appariemment de deux tables</span>. ",
     "L'appariemment est conditionné par le fait qu'un certain nombre de variables 'clés' issues de la première table aient des valeurs présentes ",
	 "<strong>à l'identique</strong> dans un <strong>même nombre</strong> de variables 'clés' de la seconde table.<br>",
     "Le résultat est généralement une table contenant l'intégralité des variables des deux tables.",
     "En cas de doublon sur un nom de variable, les variables en cause sont suffixées par '.x' et '.y'.", 
     "Le nombre de lignes du résultat effectif dépend de ce qu'on souhaite faire lorsque les valeurs issues des 'clés' d'une table n'ont pas d'écho dans l'autre.<br>",
     "Les fonctions sont complétées par le cas particulier où le nombre de clés est nul : la fonction <code>crossing</code> du package <strong>tidyr</strong>",
     "produit alors un produit cartésien, potentiellement volumineux, mais sur lequel il est ensuite possible de faire un filtre non limité à des égalités de variables.<br>",
     "<em>NOTE : la page se réinitialise dès que la jointure a fonctionné.</em>"],
   "type": "Type de jointure :",
   "type.inner": "Uniquement les lignes ayant un echo dans les deux tables",
   "type.left": "Les lignes de la table en entrée complétées ou non par celles de la seconde table",
   "type.right": "Les lignes de la seconde table complétées ou non par celles de la table en entrée",
   "type.full": "Les lignes des deux tables qu'elles aient un écho ou non dans leur vis à vis",
   "type.anti": "Les lignes de la table en entrée n'ayant aucun écho dans la seconde table",
   "type.semi": "Les lignes de la table en entrée ayant un écho dans la seconde table",
   "type.crossing": "Produit cartésien",
   "msg.result": "NOTE : Le résultat va avoir %d x %d = %d lignes."
 },
 "fuzzyjoin":{
   "menu.title": "Jointure floue",
   "page.title": "Jointure de deux tables sur critère quelconque",
   "info":[
     "Les fonctions du package <strong>fuzzyjoin</strong> permettent de compléter les fonctions d'appariement de deux tables, ",
     "en offrant la possibilité de conditionner la <span style='color:blue'>correspondance entre observations provenant de chacune des tables par autre chose qu'une égalité de clés</span>.",
     "La fonction <code>fuzzy_join</code> permet d'exprimer le fait qu'il y a correspondance entre deux observations de deux façons :<br>",
     "- soit parce que l'application d'une <strong>fonction à deux variables</strong>, une dans chaque table, renvoie <em>TRUE</em>,<br>",
     "- soit parce que le calcul d'une <strong>expression impliquant un nombre de variables quelconque</strong> renvoie <em>TRUE</em>.<br>",
     "Le résultat est une table contenant l'intégralité des variables des deux tables. En cas de doublon sur les noms, les variables en cause sont suffixées par '.x' et '.y'.<br>",
     "<em>NOTE : la page se réinitialise dès que la jointure a fonctionné.</em>"],
   "type":{
     "function": "Entrée non assistée",
     "menu": "Fonctions usuelles",
     "dist": "Distance"
   },
   "dist.col": "Distances dans :",
   "dist.max": "Distance maximum :",
   "method":{
     "osa":     "Damerau-Levenshtein retreint",
	 "dl":      "Damerau-Levenshtein complet",
     "lv":      "Levenshtein",
	 "jw":      "Jaro/Jaro-Winker",
	 "hamming": "Hamming",
	 "qgram":   "q-gramme",
	 "cosine":  "q-gramme cosinus",
	 "soundex": "Phonétique"
   },
   "parm.q":   "Taille du q-gramme (q>=1)",
   "parm.p":   "Coeff. de préfixe (0<=p<=0.25])",
   "parm.bt":  "'Winkler's boost threshold'",
   "parm.w.d": "Pénalité pour suppression",
   "parm.w.i": "Pénalité pour insertion",
   "parm.w.s": "Pénalité pour substitution",
   "parm.w.t": "Pénalité pour transposition",
   "funs":{
     "startsWith": "commence par",
	 "contains":   "contient",
	 "endsWith":   "ce termine par",
	 "example":    "*** dept corse avant/après"
   },
   "fun": "Fonction de comparaison des clés",
   "condition": "Condition sur ",
   "and": " et "
 },
 "labels":{
   "menu.title": "Libellés d'un facteur",
   "page.title": "Importer les libellés d'une variable qualitative",
   "info":[
     "La fonction <code>factor</code> permet de",
     "<span style='color:blue'>mettre une variable qualitative dans le type 'énumération'</span>,",
     "tout en précisant les libellés qui doivent apparaître pour chacune des modalités de la variable.<br>",
     "Cette page permet d'exploiter une <em>table de passage</em> définie ailleurs sous forme de table contenant deux colonnes : modalités de la variable et libellés associés."],
   "data": "Table de correspondance",
   "data.levels": "Variable donnant les codes (levels)",
   "data.labels": "Variable donnant les libellés (labels)"
 },
 "rbind":{
   "menu.title": "Empilement",
   "page.title": "Ajout de tables à la fin de la table courante",
   "info":[
     "La fonction <code>bind_rows</code> du package <strong>dplyr</strong> permet de mettre bout à bout deux tables ou plus.",
	 "Avec deux tables, la table résultat contiendra les données de la première suivie des données de la seconde.",
	 "Le contenu de chaque colonne sera issu des colonnes de même nom dans les deux tables,",
	 "et si une colonne d'une table n'est pas présente dans l'autre, les données seront mises à valeur manquante."],
   "data": "Ajouter la table",
   "msg.result": "Le résultat aura %d+(%s)=%d colonnes."
 },
 "skim":{
   "menu.title": "Analyse rapide",
   "page.title": "Analyse rapide de la table courante",
   "info":[
     "La fonction <code>skim</code> du package <strong>skimr</strong> produit une analyse rapide du contenu statistique d'une table.",
     "Pour chaque variable, en fonction de son type, elle calcule une <span style:'color:blue'>collection d'indicateurs statistiques de dispersion</span>.",
     "Le résultat est une table de données appartenant à un type de table <em>skim_df</em> dont l'édition dans cette page conduit à une présentation améliorée de son contenu.",
     "Mais cette table peut être interrogée ou re-travaillée de façon standard."],
   "skim": "Analyser les variables..."
 },
 "tabular":{
   "menu.title": "Tableaux",
   "page.title": "Tableaux sur variables qualitatives",
   "info":[
     "Le package <strong>tables</strong> est directement inspiré par la <em>PROC TABULATE</em> de SAS.",
	 "A partir de variables qualitatives qui doivent impérativement être du type 'énumération', la fonction <code>tabular</code> produit des", 
     "<span style='color:blue'>comptages ou des statistiques ventilées selon les modalités croisées</span> de ces variables.",
     "Les chiffres obtenus sont formattés et mis en page de manière à minimiser le travail nécessaire à leur intégration à un produit de diffusion.<br>",
     "Le résultat n'est pas une table mais un objet d'un type particulier qui peut être exporté sous format HTML pour être relu sous un tableur."],
   "factor": "Forcer la conversion en facteurs",
   "vars.qual": "Variables qualitatives",
   "col": "en colonne",
   "row": "en ligne",
   "nest": "Croiser les modalités des variables",
   "drop.row": "Supprimer les lignes vides",
   "drop.col": "Supprimer les colonnes vides",
   "type": "Type de tabulation",
   "type.n": "Comptage",
   "type.all": "Pourcentage",
   "type.row": "Pourcentage ligne",
   "type.col": "Pourcentage colonne",
   "type.var":  "Statistiques sur une autre variable",
   "Z": "Statistiques sur",
   "Z.funs": "Fonction(s) statistique(s)",
   "digits": "Décimales :",
   "sep": "Séparer les milliers",
   "all": "Ajouter le total",
   "all.heading": "Ensemble",
   "heading": "Titres en clair",
   "save": "Sauvegarder le tableau",
   "save.as": "Sauvegarder le tableau sous",
   "msg.error0": "*** Maître(sse)! Y aurait-il une colonne sans modalité autre que valeur manquante?",
   "msg.error1": "*** Maître(sse)! Y aurait-il trop de modalités dans une des colonnes?",
   "msg.error2": "*** Maître(sse): Y aurait-il une colonne avec une modalité de longueur nulle?",
   "overflow": "pile de noeuds débordée vers le haut"
 },
 "bar":{
   "menu.title": "Barres (données individuelles)",
   "page.title": "Distribution d'une variable qualitative",
   "info":[
     "La fonction <code>gf_bar</code> du package <strong>ggformula</strong> permet de construire un graphique de ",
     "<span style='color:blue'>barres de taille proportionnelle au nombre d'observations</span> ventilées selon les modalités d'une variable qualitative.<br>",
     "Une seconde variable qualitative peut être utilisée pour ventiler les effectifs à l'intérieur de chaque modalité de la première variable."],
   "breaks": "Graduations entières",
   "fill.type": "Couleur de remplissage des barres",
   "type.var": "En fonction de la variable...",
   "type.all": "Uniforme",
   "position.stack": "Une barre pour toutes les modalités",
   "position.dodge": "Une barre pour chaque modalité",
   "reorder": "Trier les barres",
   "coordflip": "Barres horizontales"
 },
 "col":{
   "menu.title": "Barres (données cumulées)",
   "page.title": "Distribution d'une variable qualitative",
   "info":[
     "La fonction <code>gf_col</code> du package <strong>ggformula</strong> permet de construire un graphique de ",
     "<span style='color:blue'>barres de taille proportionnelle à une variable quantitative</span> supposée être un dénombrement sur une donnée qualitative.<br>",
     "La page permet de mettre en vis à vis une seconde variable de cumuls."],
   "var.N": "Données cumulées",
   "var.M": "Données cumulées en vis à vis",
   "reorder": "Trier par",
   "coordflip": "Barres horizontales"
 },
 "histogram":{
   "menu.title": "Histogramme",
   "page.title": "Distribution d'une variable quantitative",
   "info":[
     "La fonction <code>gf_histogram</code> du package <strong>ggformula</strong> permet de représenter la",
     "<span style='color:blue'>distribution d'une variable quantitative</span> sous forme de densité.<br>",
     "La page permet de superposer la courbe représentant une estimation non paramétrique de la loi de probabibilité sous-jacente."],
   "bins.type": "Découpage en tranches",
   "bins.type.bins": "de nombre donné",
   "bins.type.binwidth": "de taille fixe",
   "kde": "Superposer l'estimation non paramétrique de densité",
   "kde.bwm": "Multiplicateur de fenêtre d'estimation"
 },
 "boxplot":{
   "menu.title": "Boite à moustache",
   "page.title": "Distributions d'une variable quantitative",
   "info":[
     "La fonction <code>gf_boxplot</code> du package <strong>ggformula</strong> permet de construire des représentations en",
     "<span style='color:blue'>boites à moustaches</span> résumant les caractéristiques essentielles de la distribution d'une variable qualitative.<br>",
     "Cette représentation est particulièrement utile pour comparer plusieurs sous-populations qui peuvent ici être déterminées par les modalités d'une",
     "seconde variable qui sera, elle, de type qualitatif."],
   "coordflip": "Graphique horizontal"
 },
 "pie":{
   "menu.title": "Diagramme en camembert",
   "page.title": "Diagramme en camembert",
   "info":[
     "Il n'existe pas de fonction <strong>ggformula</strong> ou <strong>ggplot2</strong> pour représenter la",
     "<span style='color:blue'>répartition d'une variable qualitative</span> sous forme de camembert.",
     "La représentation présentée ici exploite les possibilités des paramétrage de <strong>ggplot2</strong> en produisant le graphique à partir",
     "d'un graphique en barres proportionnelles aux effectifs qui est transformé par changement du système de coorodonnées.<br>",
	 "Les fonctions de <strong>ggformula</strong> permettent la réalisation d'un <span style='color:blue'>ensemble de graphiques</span>",
	 "conditionnés par les modalités d'une autre variable (qualitative). Cette fonctionnalité est disponible ici."],
   "facet": "Faire un graphique par modalité de"
 },
  "line":{
   "menu.title": "Courbes",
   "page.title": "Tracé de courbe",
   "info":[
     "La fonction <code>gf_line</code> du package <strong>ggformula</strong> permet de tracer des",
     "<span style='color:blue'>courbes</span>.<br>",
	 "Il est ici possible de lisser les données par ajustment polynomial autour de chaque point."],	 
   "loess": "Lisser la courbe",
   "group": "Une courbe par modalité de"
 },
  "points":{
   "menu.title": "Nuage de points",
   "page.title": "Nuage de points et tracé de courbe",
   "info":[
     "La fonction <code>gf_points</code> du package <strong>ggformula</strong> produit des graphiques de",
     "<span style='color:blue'>nuages de points</span> construits sur deux variables quantitatives. Elle est complétée par la fonction <code>gf_line</code>",
     "qui en reliant les points entre eux dessine des <span style='color:blue'>courbes</span>.<br>",
     "La taille des points peut être conditionnée par une autre variable quantitative.",
     "La couleur ou la forme des points peuvent également être dépendantes d'autres variables qualitatives. ",
     "Dans le cas de tracé de courbes, un tel paramétrage permet de superposer les courbes obtenues pour chacune des modalités de la variable supplémentaire,",
     "celle ci agissant comme dans un <code>group_by</code> de <strong>dplyr</strong>."],
   "type": "Type de graphique",
   "type.points": "Points seuls",
   "type.line": "Points reliés",
   "type.lm": "Regression linéaire",
   "color.type": "Couleur des points",
   "size.type": "Taille des points",
   "type.var": "En fonction de la variable...",
   "type.all": "Uniforme",
   "shape": "Forme des points en fonction de la variable qualitative",
   "scale": "Intervalle des graduations",
   "fixed": "Conserver les proportions"
 },
  "bin2d":{
   "menu.title": "Carte de densité",
   "page.title": "Carte de densité",
   "info":[]
 },
  "lorenz":{
   "menu.title": "Courbe de Lorenz",
   "page.title": "Courbe de Lorenz",
   "info":[] 
  },
  "maps":{
   "menu.title": "Cartographie",
   "page.title": "Expérimentations cartographiques",
   "info":[
     "Le package <strong>mapsf</strong> produit des <span style='color:blue'>cartographies thématiques simples</span>.<br>",
	 "Cette page nécessite un fond de carte issu de l'import d'un fichier <strong>SHP</strong>, enrichi des données à cartographier.<br>",
     "<em>NOTE : Les fonctionnalités présentées ici ne le sont qu'à titre démonstratif.</em>"],
   "theme": "Thème",
   "legend": "Position de la légende",
   "legends":{
     "default": "<defaut>",
     "topleft": "En haut à gauche",
     "top": "En haut",
     "topright": "En haut à droite",
     "right": "A droite",
     "bottomright": "En bas à droite",
     "bottom": "En bas",
     "bottomleft": "En bas à gauche",
     "left": "A gauche"
   },
   "labels.var": "Etiquettes avec",
   "labels.table": "de la table",
   "labels.col": "Couleur",
   "labels.cex": "Taille",
   "type1.choro": "A-plats de couleur",
   "type": "Type de cartographie",
   "type1.prop": "Symboles proportionnels",
   "type2.typo": "Classes",
   "type2.symb": "Symboles",
   "breaks": "Methode de discrétisation",
   "breaks.methods":{
     "quantile": "quantile",
     "kmeans": "kmeans",
     "fisher": "Fisher",
     "jenks": "Jenks"
   },
   "nbreaks": "Nombre de classes",
   "pal": "Palette",
   "borders": "Tracer les contours",
   "current": "Fond de carte associé",
   "add": "Couches additionnelles",
   "color": "Couleur du fond",
   "border": "Couleur du contour",
   "lwd": "Epaisseur du contour",
   "order": "Ordre des couches",
   "analysis" : "Analyse",
   "none": "<aucun>"
 },
  "edit":{
   "menu.title": "Editer",
   "page.title": "Editer la table courante",
   "info":["Il n'existe pas de fonction R permettant la mise à jour interactive d'une table.<br>",
           "Mais le package <strong>rhandsontable</strong> permet de construire facilement des applications <strong>shiny</strong>",
		   "qui le font sur de petites tables. Le package reconnait plusieurs des types de données de R.<br>",
           "Le <strong>double-clic</strong> sur une cellule permet de modifier la cellule,",
           "éventuellement avec l'aide d'un menu de valeurs possibles (facteurs) ou d'un calendrier (dates).<br>",
		   "Le <strong>clic droit</strong> donne accès, entre autres, à des fonctions d'ajout et de suppression de lignes.<br>",
           "ATTENTION : Les modifications de la table en mémoire ne seront effectives qu'après validation de celles ci.<br>",
           "<em>Qui a besoin d'Excel ou de Calc?</em>"],
   "error.size": "Table trop grosse!",
   "error.class": "Présence d'un type de données non supporté.",
   "save": "Valider les modifications",
   "width": "Largeur des noms de lignes"
  }
}